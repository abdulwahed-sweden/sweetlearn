use actix_web::{web, App, HttpServer, HttpResponse, Result, middleware::Logger};
use actix_cors::Cors;
use serde::{Deserialize, Serialize};
use chrono::Utc;
use dotenv::dotenv;
use std::env;
use validator::Validate;

#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: i32,
    email: String,
    #[serde(skip_serializing)] // Don't return password hash in responses
    password_hash: String,
    created_at: String,
}

#[derive(Debug, Deserialize, Validate)] // Added Validate trait
struct RegisterRequest {
    #[validate(email)] // Email validation
    email: String,
    #[validate(length(min = 8))] // Password length validation
    password: String,
}

#[derive(Debug, Deserialize, Validate)]
struct LoginRequest {
    #[validate(email)]
    email: String,
    password: String,
}

// Health check endpoint
async fn health() -> Result<HttpResponse> {
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "status": "ok",
        "version": env!("CARGO_PKG_VERSION"),
        "timestamp": Utc::now().to_rfc3339()
    })))
}

// Get users endpoint
async fn get_users() -> Result<HttpResponse> {
    // In a real app, this would come from a database
    let mock_users = vec![
        User {
            id: 1,
            email: "aboud@example.com".to_string(),
            password_hash: "hashed_password_1".to_string(),
            created_at: "2024-01-01T00:00:00Z".to_string(),
        },
        User {
            id: 2,
            email: "mansour@example.com".to_string(),
            password_hash: "hashed_password_2".to_string(),
            created_at: "2024-01-02T00:00:00Z".to_string(),
        },
    ];

    Ok(HttpResponse::Ok().json(mock_users))
}

// Register user endpoint
async fn register_user(
    user_data: web::Json<RegisterRequest>,
) -> Result<HttpResponse> {
    // Validate input
    if let Err(validation_errors) = user_data.validate() {
        return Ok(HttpResponse::BadRequest().json(serde_json::json!({
            "error": "Validation failed",
            "details": validation_errors
        })));
    }

    // Here you would:
    // 1. Check if email already exists
    // 2. Hash the password (use argon2 or bcrypt)
    // 3. Save to database
    
    log::info!("Registering new user: {}", user_data.email);
    
    let new_user = User {
        id: 3, // Would be auto-generated by database
        email: user_data.email.clone(),
        password_hash: format!("hashed_{}", user_data.password), // In real app, use proper hashing
        created_at: Utc::now().to_rfc3339(),
    };

    Ok(HttpResponse::Created().json(serde_json::json!({
        "message": "User registered successfully",
        "user_id": new_user.id,
        "email": new_user.email,
        "created_at": new_user.created_at
    })))
}

// Login endpoint
async fn login_user(
    user_data: web::Json<LoginRequest>,
) -> Result<HttpResponse> {
    if let Err(validation_errors) = user_data.validate() {
        return Ok(HttpResponse::BadRequest().json(serde_json::json!({
            "error": "Validation failed",
            "details": validation_errors
        })));
    }

    // Here you would:
    // 1. Find user by email
    // 2. Verify password hash
    // 3. Generate JWT token
    
    log::info!("Login attempt for: {}", user_data.email);
    
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Login successful",
        "token": "mock_jwt_token_here",
        "expires_in": 3600 // 1 hour
    })))
}

// Error handler
fn json_error_handler(err: actix_web::error::JsonPayloadError, _: &actix_web::HttpRequest) -> actix_web::Error {
    use actix_web::error::JsonPayloadError;

    let error_message = match err {
        JsonPayloadError::ContentType => "Unsupported content type".to_string(),
        JsonPayloadError::Deserialize(json_err) => format!("Invalid JSON: {}", json_err),
        JsonPayloadError::Payload(payload_err) => payload_err.to_string(),
        _ => "Unknown error occurred".to_string(),
    };

    actix_web::error::ErrorBadRequest(serde_json::json!({
        "error": "Invalid request",
        "message": error_message
    }))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Load environment variables
    dotenv().ok();
    
    // Initialize logger
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp(None)
        .init();

    log::info!("üöÄ Starting SweetLearn Backend Server v{}...", env!("CARGO_PKG_VERSION"));
    log::info!("üì° Server running on: http://localhost:8080");
    log::info!("üåê Allowed CORS origin: http://localhost:3000");

    HttpServer::new(|| {
        // Configure CORS
        let cors = Cors::default()
            .allowed_origin("http://localhost:3000")
            .allowed_methods(vec!["GET", "POST", "PUT", "DELETE"])
            .allowed_headers(vec![
                "Content-Type",
                "Authorization",
                "Accept",
                "X-Requested-With"
            ])
            .supports_credentials()
            .max_age(3600);

        App::new()
            .wrap(cors)
            .wrap(Logger::new("%a %{User-Agent}i %r %s %b %Dms"))
            .app_data(
                web::JsonConfig::default()
                    .limit(4096) // Limit JSON payload size
                    .error_handler(json_error_handler)
            )
            .route("/health", web::get().to(health))
            .service(
                web::scope("/api")
                    .route("/users", web::get().to(get_users))
                    .route("/register", web::post().to(register_user))
                    .route("/login", web::post().to(login_user))
            )
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}